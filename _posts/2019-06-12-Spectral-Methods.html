---
layout: post
title: "Spectral Methods and the Heat Equation"
date: 2019-06-12
---
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>main</title>
  <style>
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style>
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<p>We all know that the Fourier transform is pretty magical, but it turns out to be extra special to deal with certain PDEs. As it turns out, since the Fourier basis gives spectral accuracy for smooth functions, we can approximate the derivative of functions with spectral accuracy and in <span class="math inline">\(\theta(n\log(n))\)</span> time, since we have the Fast Fourier Transform. Therefore, as a substitute to finite difference methods, we can use spectral methods to discretize the spacial derivative operator.</p>
<h1 id="discretizing-the-heat-equation">Discretizing the Heat Equation</h1>
<p>Let’s look at the initial-boundary value problem for the 1D heat equation:</p>
<p><span class="math display">\[\begin{cases}
  \frac{\partial u}{\partial t} = \alpha \frac{\partial^2 u}{\partial x^2}
  + f(t,x), &amp; x \in [0, 2\pi), t \in (0, T] \\
  u(x,0) = u_0(x), &amp; x \in [0, 2\pi) \\
  u(0,t) = u(2\pi, t) = 0
\end{cases}\]</span></p>
<h1 id="code-spectral-differentiation">Code: Spectral Differentiation</h1>
<p>If you would like to look at the code for spectral differentiation, I would have to reference you to Trefethen’s excellent text called <em>Spectral Methods in Matlab</em>; really excellent on the matter. As far as the code I used, take a look!</p>
<div class="sourceCode" id="cb1" data-fontsize="\footnotesize" data-linenos=""><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb1-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb1-2" title="2"><span class="co"> * FILE: spectral_diff.h</span></a>
<a class="sourceLine" id="cb1-3" title="3"><span class="co"> * AUTHOR: Abhijit Chowdhary 2019/06/07.</span></a>
<a class="sourceLine" id="cb1-4" title="4"><span class="co"> * -------------------------------------</span></a>
<a class="sourceLine" id="cb1-5" title="5"><span class="co"> * Provides a function to differentiate a function applied to the grid [0,2*pi].</span></a>
<a class="sourceLine" id="cb1-6" title="6"><span class="co"> */</span></a>
<a class="sourceLine" id="cb1-7" title="7"></a>
<a class="sourceLine" id="cb1-8" title="8"><span class="pp">#ifndef INTERPFT_H</span></a>
<a class="sourceLine" id="cb1-9" title="9"><span class="pp">#define INTERPFT_H</span></a>
<a class="sourceLine" id="cb1-10" title="10"></a>
<a class="sourceLine" id="cb1-11" title="11"><span class="pp">#include </span><span class="im">&lt;fftw3.h&gt;</span></a>
<a class="sourceLine" id="cb1-12" title="12"></a>
<a class="sourceLine" id="cb1-13" title="13"><span class="co">/* </span></a>
<a class="sourceLine" id="cb1-14" title="14"><span class="co"> * FUNCTION: spectral_diff</span></a>
<a class="sourceLine" id="cb1-15" title="15"><span class="co"> * -----------------------</span></a>
<a class="sourceLine" id="cb1-16" title="16"><span class="co"> * Differentiates the function f onto a finer grid via spectral interpolation.</span></a>
<a class="sourceLine" id="cb1-17" title="17"><span class="co"> *</span></a>
<a class="sourceLine" id="cb1-18" title="18"><span class="co"> * INPUT:</span></a>
<a class="sourceLine" id="cb1-19" title="19"><span class="co"> * fftw_complex &amp;fxx: An array of complex numbers describing the function which</span></a>
<a class="sourceLine" id="cb1-20" title="20"><span class="co"> *                    the interpolation is to be taken on applied to the grid</span></a>
<a class="sourceLine" id="cb1-21" title="21"><span class="co"> *                    [0,2*pi].</span></a>
<a class="sourceLine" id="cb1-22" title="22"><span class="co"> * int N: Spacing of the above grid, i.e. fxx[k] = f(2*pi*k/N).</span></a>
<a class="sourceLine" id="cb1-23" title="23"><span class="co"> * int M: Spacing of output grid, i.e. out[k] = f&#39;(2*pi*k/M). M &gt;= N must be</span></a>
<a class="sourceLine" id="cb1-24" title="24"><span class="co"> *        true, if not M is set to N and out is realloced to size N. If this</span></a>
<a class="sourceLine" id="cb1-25" title="25"><span class="co"> *        fails, function returns having done nothing.</span></a>
<a class="sourceLine" id="cb1-26" title="26"><span class="co"> * OUTPUT:</span></a>
<a class="sourceLine" id="cb1-27" title="27"><span class="co"> * fftw_complex &amp;out: Output array of size M where out[k] = f&#39;(2*pi*k/M).</span></a>
<a class="sourceLine" id="cb1-28" title="28"><span class="co"> */</span></a>
<a class="sourceLine" id="cb1-29" title="29"><span class="kw">inline</span> <span class="dt">void</span> </a>
<a class="sourceLine" id="cb1-30" title="30">spectral_diff(fftw_complex *fxx, <span class="dt">int</span> N, fftw_complex *out, <span class="dt">int</span> M)</a>
<a class="sourceLine" id="cb1-31" title="31">{</a>
<a class="sourceLine" id="cb1-32" title="32">  <span class="cf">if</span> (M &lt; N)</a>
<a class="sourceLine" id="cb1-33" title="33">  {</a>
<a class="sourceLine" id="cb1-34" title="34">    fftw_complex *new_out = (fftw_complex *)realloc(out, N);</a>
<a class="sourceLine" id="cb1-35" title="35">    <span class="cf">if</span> (new_out == NULL) { <span class="cf">return</span>; }</a>
<a class="sourceLine" id="cb1-36" title="36">    <span class="cf">else</span> { out = new_out; M = N; }</a>
<a class="sourceLine" id="cb1-37" title="37">  }</a>
<a class="sourceLine" id="cb1-38" title="38">  fftw_plan p = fftw_plan_dft_1d(N, fxx, out, FFTW_FORWARD, FFTW_ESTIMATE);</a>
<a class="sourceLine" id="cb1-39" title="39">  fftw_execute(p); fftw_destroy_plan(p);</a>
<a class="sourceLine" id="cb1-40" title="40"></a>
<a class="sourceLine" id="cb1-41" title="41">  <span class="dt">int</span> nyqst = N/<span class="dv">2</span>;</a>
<a class="sourceLine" id="cb1-42" title="42">  <span class="cf">for</span> (<span class="dt">int</span> k = <span class="dv">0</span>; k &lt; N; ++k)</a>
<a class="sourceLine" id="cb1-43" title="43">  { <span class="co">// Build [y(1:nyqst), zeros(M-N), y(nyqst+1:N)]</span></a>
<a class="sourceLine" id="cb1-44" title="44">    <span class="co">// Multiply by M/N for oversampling, then by 1/M for normalized ifft.</span></a>
<a class="sourceLine" id="cb1-45" title="45">    <span class="dt">int</span> w = (k &lt; nyqst) ? k : k-N;</a>
<a class="sourceLine" id="cb1-46" title="46">    <span class="dt">double</span> temp = out[k][<span class="dv">0</span>]; out[k][<span class="dv">0</span>] = -w*out[k][<span class="dv">1</span>]/N; out[k][<span class="dv">1</span>] = w*temp/N;</a>
<a class="sourceLine" id="cb1-47" title="47">    <span class="cf">if</span> (k &gt;= nyqst)</a>
<a class="sourceLine" id="cb1-48" title="48">    {</a>
<a class="sourceLine" id="cb1-49" title="49">      out[k+(M-N)][<span class="dv">0</span>] = out[k][<span class="dv">0</span>]; out[k+(M-N)][<span class="dv">1</span>] = out[k][<span class="dv">1</span>]; </a>
<a class="sourceLine" id="cb1-50" title="50">      out[k][<span class="dv">0</span>] = <span class="dv">0</span>; out[k][<span class="dv">1</span>] = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb1-51" title="51">    }</a>
<a class="sourceLine" id="cb1-52" title="52">  }</a>
<a class="sourceLine" id="cb1-53" title="53">  <span class="cf">if</span> (N % <span class="dv">2</span> == <span class="dv">0</span>)</a>
<a class="sourceLine" id="cb1-54" title="54">  { <span class="co">// If even divide energy to symmetrize frequencies.</span></a>
<a class="sourceLine" id="cb1-55" title="55">    out[M-nyqst][<span class="dv">0</span>] /= <span class="dv">2</span>; out[M-nyqst][<span class="dv">1</span>] /= <span class="dv">2</span>;</a>
<a class="sourceLine" id="cb1-56" title="56">    out[nyqst][<span class="dv">0</span>] = out[M-nyqst][<span class="dv">0</span>]; out[nyqst][<span class="dv">1</span>] = out[M-nyqst][<span class="dv">1</span>];</a>
<a class="sourceLine" id="cb1-57" title="57">  }</a>
<a class="sourceLine" id="cb1-58" title="58"></a>
<a class="sourceLine" id="cb1-59" title="59">  fftw_plan p = fftw_plan_dft_1d(M, out, out, FFTW_BACKWARD, FFTW_ESTIMATE);</a>
<a class="sourceLine" id="cb1-60" title="60">  fftw_execute(p); fftw_destroy_plan(p);</a>
<a class="sourceLine" id="cb1-61" title="61">}</a>
<a class="sourceLine" id="cb1-62" title="62"></a>
<a class="sourceLine" id="cb1-63" title="63"><span class="pp">#endif</span></a></code></pre></div>
</body>
</html>
